# 实时推理性能差的原因分析

## 可能的主要原因

### 1. ⚠️ **采样率不一致（最可能）**

**问题**：
- 训练数据：100Hz采样率，2000ms窗口 = 200个样本
- Arduino实际采样率可能不是精确的100Hz（可能是119Hz或其他）
- 即使设置了`targetSampleRate = 100`，`IMU.accelerationSampleRate()`返回的实际采样率可能不同

**检查方法**：
```cpp
// 在setup()中已经有检查代码，查看串口输出：
// 如果看到警告：实际采样率与目标采样率不一致
```

**影响**：
- 如果实际采样率是119Hz，2秒会采集238个样本，而不是200个
- 这会导致特征提取时使用的样本数量不一致
- 特征值会有偏差，影响模型性能

**解决方案**：
- 使用固定时间窗口（2000ms）而不是固定样本数
- 或者调整采样率以匹配训练数据

---

### 2. **窗口对齐问题**

**问题**：
- 测试集数据是从完整手势中准确提取的窗口
- 实时推理时，按钮触发后开始采集，可能没有捕捉到手势的开始部分
- 窗口可能包含了手势的前置动作或后续静止状态

**影响**：
- 特征分布与训练数据不一致
- 模型在非对齐的窗口上表现差

**解决方案**：
- 使用滑动窗口 + 能量检测来找到手势的起始点
- 或者在数据采集时确保手势从静止状态开始

---

### 3. **数据质量问题**

**问题**：
- 训练数据可能经过预处理（滤波、去噪）
- 实时数据可能包含更多噪声
- 传感器可能有漂移或校准差异

**检查方法**：
- 打印实时采集的原始IMU数据
- 与训练数据中的样本对比数值范围

**解决方案**：
- 添加简单的高通滤波器去除直流偏置
- 添加磁力计校准（如果使用）

---

### 4. **传感器坐标系不一致**

**问题**：
- 训练时和推理时传感器的安装方向可能不同
- IMU的坐标系可能没有对齐

**影响**：
- 加速度、角速度的方向相反或旋转
- 特征值完全不对

**解决方案**：
- 确保推理时传感器的安装方向与训练时一致
- 或者对数据进行坐标系转换

---

### 5. **特征提取数值精度问题**

**问题**：
- Python使用64位浮点数，Arduino使用32位
- 标准差计算的数值稳定性可能不同

**当前实现对比**：
- Python: `stds = v.std(axis=0)` → 使用数值稳定的算法
- Arduino: `variance = (sum_sq / num_samples) - (mean * mean)` → 可能因数值误差导致负数

**检查方法**：
- 在Arduino中打印提取的特征值
- 与Python提取的相同数据的特征值对比

**已有保护**：
```cpp
features[feat_idx++] = sqrt(max(0.0, variance)); // 防止负数
```

---

### 6. **归一化范围溢出**

**问题**：
- 实时数据的特征值可能超出训练时的`feature_min`和`feature_max`范围
- 归一化后的值会超出[0,1]范围

**检查方法**：
- 在归一化前打印原始特征值
- 检查是否有值超出feature_min/max的范围

**解决方案**：
- 使用clip操作限制特征值在[min, max]范围内
- 或者重新计算归一化参数以包含实时数据范围

---

## 诊断步骤

### 步骤1：验证采样率和样本数
```cpp
// 在采集完成后添加
Serial.print("实际采集样本数: ");
Serial.println(samplesRead);
Serial.print("预期样本数: ");
Serial.println(numSamples);
Serial.print("实际采集时间: ");
Serial.print((millis() - collectionStartTime));
Serial.println(" ms");
```

### 步骤2：打印原始特征值对比
```cpp
// 在extractFeatures()后添加
Serial.println("提取的特征值（前10维）:");
for (int i = 0; i < 10; i++) {
  Serial.print(features[i], 6);
  Serial.print(" ");
}
Serial.println();
```

### 步骤3：打印归一化后的值
```cpp
// 在normalizeInputBuffer()后添加
Serial.println("归一化后的值（前10维）:");
for (int i = 0; i < 10; i++) {
  Serial.print(input[i], 6);
  Serial.print(" ");
}
Serial.println();
```

### 步骤4：检查特征值范围
```cpp
// 检查是否有特征值超出归一化范围
for (int i = 0; i < 75; i++) {
  if (features[i] < feature_min[i] || features[i] > feature_max[i]) {
    Serial.print("警告: 特征 ");
    Serial.print(i);
    Serial.print(" 超出范围: ");
    Serial.print(features[i], 6);
    Serial.print(" 不在 [");
    Serial.print(feature_min[i], 6);
    Serial.print(", ");
    Serial.print(feature_max[i], 6);
    Serial.println("]");
  }
}
```

---

## 推荐的修复方案

### 方案1：使用固定时间窗口（推荐）
```cpp
const unsigned long windowDurationMs = 2000; // 固定2秒窗口
unsigned long collectionStartTime = 0;

// 在loop()中：
if (samplesRead == 0) {
  collectionStartTime = millis();
  lastSampleTime = millis();
}

while ((millis() - collectionStartTime) < windowDurationMs) {
  // 采集所有可用样本，不限制数量
  if (IMU.accelerationAvailable() && IMU.gyroscopeAvailable()) {
    // ... 采集数据
  }
}
// 然后调整特征提取使用实际采集的样本数
```

### 方案2：插值/重采样到固定样本数
```cpp
// 如果实际采集了N个样本（N != 200），进行线性插值到200个样本
void resampleToFixedSize(float* input_data, int input_samples, 
                         float* output_data, int output_samples) {
  for (int i = 0; i < output_samples; i++) {
    float idx = (float)i / (output_samples - 1) * (input_samples - 1);
    int idx_low = (int)idx;
    int idx_high = min(idx_low + 1, input_samples - 1);
    float t = idx - idx_low;
    for (int ch = 0; ch < 9; ch++) {
      output_data[i * 9 + ch] = input_data[idx_low * 9 + ch] * (1-t) + 
                                 input_data[idx_high * 9 + ch] * t;
    }
  }
}
```

### 方案3：改进归一化以处理溢出
```cpp
void normalizeInputBuffer() {
  for (int j = 0; j < IN_VEC_SIZE; j++) {
    float range = feature_max[j] - feature_min[j];
    
    if (abs(range) < 1e-6) { 
      input[j] = 0.0; 
    } else {
      // Clip到[min, max]范围
      float clipped = max(feature_min[j], min(feature_max[j], input[j]));
      input[j] = (clipped - feature_min[j]) / range;
    }
  }
}
```

---

## 最可能的问题排序

1. **采样率/样本数不一致** (90%可能性)
2. **窗口对齐问题** (60%可能性)
3. **数据质量/噪声** (40%可能性)
4. **归一化范围溢出** (30%可能性)
5. **传感器坐标系** (20%可能性)

建议先检查前两个问题！


